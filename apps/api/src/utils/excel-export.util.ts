import ExcelJS from 'exceljs';

export interface ExcelColumn {
  header: string;
  key: string;
  width?: number;
  numFmt?: string; // e.g. '"Rs."#,##0.00'
}

export interface ExcelExportOptions {
  title: string;
  filters: Record<string, string>;
  generatedBy: string;
  columns: ExcelColumn[];
  data: Record<string, any>[];
  summaryRow?: Record<string, any>;
}

const HEADER_FILL: ExcelJS.Fill = {
  type: 'pattern',
  pattern: 'solid',
  fgColor: { argb: 'FF1E40AF' }, // blue-800
};

const HEADER_FONT: Partial<ExcelJS.Font> = {
  bold: true,
  color: { argb: 'FFFFFFFF' },
  size: 11,
};

const TITLE_FONT: Partial<ExcelJS.Font> = {
  bold: true,
  size: 14,
  color: { argb: 'FF1E40AF' },
};

const META_FONT: Partial<ExcelJS.Font> = {
  size: 10,
  color: { argb: 'FF64748B' }, // slate-500
};

const SUMMARY_FILL: ExcelJS.Fill = {
  type: 'pattern',
  pattern: 'solid',
  fgColor: { argb: 'FFF1F5F9' }, // slate-100
};

const ALT_ROW_FILL: ExcelJS.Fill = {
  type: 'pattern',
  pattern: 'solid',
  fgColor: { argb: 'FFF8FAFC' }, // slate-50
};

const BORDER_STYLE: Partial<ExcelJS.Borders> = {
  top: { style: 'thin', color: { argb: 'FFE2E8F0' } },
  bottom: { style: 'thin', color: { argb: 'FFE2E8F0' } },
  left: { style: 'thin', color: { argb: 'FFE2E8F0' } },
  right: { style: 'thin', color: { argb: 'FFE2E8F0' } },
};

export async function generateExcel(options: ExcelExportOptions): Promise<Buffer> {
  const { title, filters, generatedBy, columns, data, summaryRow } = options;
  const workbook = new ExcelJS.Workbook();
  workbook.creator = 'Hisham Traders ERP';
  workbook.created = new Date();

  const worksheet = workbook.addWorksheet(title, {
    views: [{ state: 'frozen', ySplit: 6 }], // Freeze header rows
  });

  // ── Row 1: Title ──
  const titleRow = worksheet.addRow([title]);
  titleRow.getCell(1).font = TITLE_FONT;
  worksheet.mergeCells(1, 1, 1, columns.length);

  // ── Row 2: Generated timestamp ──
  const tsRow = worksheet.addRow([`Generated: ${new Date().toLocaleString('en-PK', { dateStyle: 'medium', timeStyle: 'short' })}`]);
  tsRow.getCell(1).font = META_FONT;
  worksheet.mergeCells(2, 1, 2, columns.length);

  // ── Row 3: Generated by ──
  const byRow = worksheet.addRow([`Generated By: ${generatedBy}`]);
  byRow.getCell(1).font = META_FONT;
  worksheet.mergeCells(3, 1, 3, columns.length);

  // ── Row 4: Filters ──
  const filterStr = Object.entries(filters)
    .filter(([, v]) => v && v !== 'All')
    .map(([k, v]) => `${k}: ${v}`)
    .join('  |  ');
  const filterRow = worksheet.addRow([filterStr ? `Filters: ${filterStr}` : 'Filters: None']);
  filterRow.getCell(1).font = META_FONT;
  worksheet.mergeCells(4, 1, 4, columns.length);

  // ── Row 5: Spacer ──
  worksheet.addRow([]);

  // ── Row 6: Header ──
  const headerRow = worksheet.addRow(columns.map((c) => c.header));
  headerRow.eachCell((cell) => {
    cell.font = HEADER_FONT;
    cell.fill = HEADER_FILL;
    cell.border = BORDER_STYLE;
    cell.alignment = { vertical: 'middle', horizontal: 'center' };
  });
  headerRow.height = 24;

  // ── Data rows ──
  data.forEach((row, idx) => {
    const dataRow = worksheet.addRow(columns.map((c) => row[c.key] ?? ''));
    dataRow.eachCell((cell) => {
      cell.border = BORDER_STYLE;
      cell.alignment = { vertical: 'middle' };
    });
    // Alternate row coloring
    if (idx % 2 === 1) {
      dataRow.eachCell((cell) => {
        cell.fill = ALT_ROW_FILL;
      });
    }
  });

  // ── Summary row ──
  if (summaryRow) {
    const sumRow = worksheet.addRow(columns.map((c) => summaryRow[c.key] ?? ''));
    sumRow.eachCell((cell) => {
      cell.font = { bold: true, size: 11 };
      cell.fill = SUMMARY_FILL;
      cell.border = BORDER_STYLE;
    });
  }

  // ── Column widths & number formatting ──
  columns.forEach((col, i) => {
    const wsCol = worksheet.getColumn(i + 1);
    wsCol.width = col.width || 15;
    if (col.numFmt) {
      // Apply numFmt only to data rows (row 7 onward)
      for (let r = 7; r <= 6 + data.length + (summaryRow ? 1 : 0); r++) {
        const cell = worksheet.getCell(r, i + 1);
        cell.numFmt = col.numFmt;
      }
    }
  });

  const arrayBuffer = await workbook.xlsx.writeBuffer();
  return Buffer.from(arrayBuffer);
}
